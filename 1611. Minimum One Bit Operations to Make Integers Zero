# leetcode

题目描述（困难）
============

给你一个整数 n，你需要重复执行多次下述操作将其转换为 0 ：

翻转 n 的二进制表示中最右侧位（第 0 位）。
如果第 (i-1) 位为 1 且从第 (i-2) 位到第 0 位都为 0，则翻转 n 的二进制表示中的第 i 位。
返回将 n 转换为 0 的最小操作次数。

示例：
输入：n = 6
输出：4
解释：6 的二进制表示为 "110".
"110" -> "010" ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。
"010" -> "011" ，执行的是第 1 种操作。
"011" -> "001" ，执行的是第 2 种操作，因为第 0 位为 1 。
"001" -> "000" ，执行的是第 1 种操作。

解法一：异或
==========

```java
public int minimumOneBitOperations(int n) {
    int res = 0;
    while(n != 0){
        res ^= n;
        n >>= 1;}
    return res;}
```

总结：
====

又是一个总结规律的题，我还是不明白怎么总结出来的，不过遇到二进制的问题，还是多考虑规律，不能直接感觉题目要求来递归或是别的。
